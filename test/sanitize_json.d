import std.bigint;
import std.exception : assumeUnique;
import std.string : startsWith, replace;
import std.format : formattedWrite, format;
import std.stdio;

import json;

void usage()
{
    writeln("Usage: santize_json <input-json> [<output-json>]");
}
int main(string[] args)
{
    args = args[1 .. $];
    if (args.length == 0)
    {
        usage();
        return 1;
    }
    string inFilename = args[0];
    File outFile;
    if(args.length == 1)
    {
        outFile = stdout;
    }
    else if(args.length == 2)
    {
        outFile = File(args[1], "w");
    }
    else
    {
        writeln("Error: too many command line arguments");
        return 1;
    }

    string jsonText;
    {
        auto inFile = File(inFilename, "r");
        auto inFileSizeLong = inFile.size;
        assert(inFileSizeLong < size_t.max, "file too large");
        size_t inFileSize = cast(size_t)inFileSizeLong;
        char[] buffer = new char[inFileSize + 1];
        assert(inFileSize == inFile.rawRead(buffer[0..inFileSize]).length);
        buffer[inFileSize] = '\0';
        jsonText = assumeUnique(buffer);
    }
    auto json = parseJson(jsonText, inFilename);

    sanitize(json.array);

    auto writer = JsonWriter(outFile, 0);
    writer.writeJson(json);
    return 0;
}

void sanitize(JsonValue[] rootArray)
{
    foreach (objNode; rootArray)
    {
        auto obj = objNode.object;
        auto kind = obj.getAs!string("kind");
        if (kind == "compilerInfo")
            sanitizeCompilerInfo(obj);
        else if (kind == "buildInfo")
            sanitizeBuildInfo(obj);
        else if(kind == "module")
            sanitizeSyntaxNode(objNode);
        else if(kind == "semantics")
            sanitizeSemantics(obj);
    }
}

void removeString(JsonValue* value)
{
    assert(value.type == JsonType.string);
    *value = JsonValue("VALUE_REMOVED_FOR_TEST");
}
void removeNumber(JsonValue* value)
{
    assert(value.type == JsonType.number);
    *value = JsonValue(BigInt(0));
}
void removeStringIfExists(JsonObjectMemberReference member)
{
    if (!member.isNull)
        removeString(member.value);
}

void sanitizeCompilerInfo(JsonObject buildInfo)
{
    removeString(buildInfo.getRef("binary").value);
    removeString(buildInfo.getRef("version").value);
}
void sanitizeBuildInfo(JsonObject buildInfo)
{
    removeString(buildInfo.getRef("cwd").value);
    removeStringIfExists(buildInfo.tryGetRef("config"));
    removeStringIfExists(buildInfo.tryGetRef("lib"));
    {
        auto importPaths = buildInfo.getAs!(JsonValue[])("importPaths");
        foreach(ref path; importPaths)
        {
            path = JsonValue(normalizeFile(path.as!string));
        }
    }
}
void sanitizeSyntaxNode(JsonValue value)
{
    if (value.type == JsonType.array)
    {
        foreach (ref element; value.arrayData)
        {
            sanitizeSyntaxNode(element);
        }
    }
    else if(value.type == JsonType.object)
    {
        foreach (ref member; value.objectData.members)
        {
            if (member.name == "file")
                removeString(&member.value);
            else if (member.name == "deco")
                removeString(&member.value);
            else if (member.name == "offset")
                removeNumber(&member.value);
            else
                sanitizeSyntaxNode(member.value);
        }
    }
}

void sanitizeSemantics(JsonObject semantics)
{
    import std.array : appender;

    auto modulesNode = semantics.getRef("modules");
    auto modulesArray = modulesNode.value.array;
    auto newModules = appender!(JsonValue[])();
    foreach (ref semanticModuleNode; modulesArray)
    {
        auto semanticModule = semanticModuleNode.object;
        auto moduleName = semanticModule.getAs!string("name");
        if(moduleName.startsWith("std.", "core.", "etc.") || moduleName == "object")
        {
           // remove druntime/phobos modules since they can change for each
           // platform
           continue;
        }
        auto fileNode = semanticModule.getRef("file");
        *fileNode.value = JsonValue(normalizeFile(fileNode.value.as!string));
        newModules.put(JsonValue(semanticModule));
    }
    *modulesNode.value = JsonValue(newModules.data);
}

auto normalizeFile(string file)
{
    version(Windows)
        return file.replace("\\", "/");
    return file;
}


// Mimics the json format generated by DMD
// so that the resulting JSON can be compared
// using a simple diff
struct JsonWriter
{
    File outFile;
    uint depth;
    void indent()
    {
        foreach (i; 0 .. depth)
            outFile.write(" ");
    }
    void writeJson(ref const JsonValue node)
    {
        final switch(node.type)
        {
            case JsonType.null_:
                outFile.write("null");
                break;
            case JsonType.bool_:
                outFile.write(node.boolData);
                break;
            case JsonType.string:
                outFile.writef("\"%s\"", formatEscaped(node.stringData));
                break;
            case JsonType.number:
                outFile.writef("%s", node.bigIntData);
                break;
            case JsonType.object:
                if (node.objectData.members.length == 0)
                    write("{}");
                else
                {
                    write("{\n");
                    depth++;
                    size_t i = 0;
                    foreach (member; node.objectData.members)
                    {
                        indent();
                        outFile.writef("\"%s\" : ", member.name);
                        writeJson(member.value);
                        i++;
                        if(i != node.objectData.members.length)
                            outFile.write(",");
                        outFile.write("\n");
                    }
                    depth--;
                    indent();
                    write("}");
                }
                break;
            case JsonType.array:
                if (node.arrayData.length == 0)
                    write("[]");
                else
                {
                    write("[\n");
                    depth++;
                    size_t i = 0;
                    foreach (element; node.arrayData)
                    {
                        indent();
                        writeJson(element);
                        
                        i++;
                        if(i != node.arrayData.length)
                            outFile.write(",");
                        outFile.write("\n");
                    }
                    depth--;
                    indent();
                    write("]");
                }
                break;
        }
    }
}
